% Copyright 2012 Vastech SA (PTY) LTD
% 
%    Licensed under the Apache License, Version 2.0 (the "License");
%    you may not use this file except in compliance with the License.
%    You may obtain a copy of the License at
% 
%        http://www.apache.org/licenses/LICENSE-2.0
% 
%    Unless required by applicable law or agreed to in writing, software
%    distributed under the License is distributed on an "AS IS" BASIS,
%    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%    See the License for the specific language governing permissions and
%    limitations under the License.


\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage[margin=2cm]{geometry}
\usepackage[parfill]{parskip}
\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.jpg, .pdf}
\usepackage{longtable}
\usepackage{pdflscape}
\usepackage{pdfpages}
\usepackage[bookmarksnumbered,bookmarksopen,bookmarksopenlevel=2,pdffitwindow]{hyperref}

\begin{document}
\begin{center}
	{\Huge Learn You a gocc for Great Good} \\
	{\large or \\
	How to save the world by using compiler theory \\
	\vspace{1cm}
	2013-04-24}\\
	\vspace{1cm}
	\includegraphics[scale=.1]{gocc}
\end{center}
\tableofcontents

\newcommand{\TBD}{\textcolor{red}{TBD}}
\newcommand{\TBDx}[1]{\textcolor{red}{TBD:} #1}
\newcommand{\Go}{{\em Go}\ }
\newcommand{\Code}[1]{{\bf #1} } 
\newcommand{\gocc}{{\em gocc}\ }
\newcommand{\Clang}{{\em C} language}

\section{Introduction}
	gocc is an LR(1) parser generator with automatic LR(1) conflict resolution (see section~\ref{sec:lr conflicts}) and automatic parser error recovery (see section~\ref{sec:error recovery}). It has a simple syntax directed translation scheme (SDT) embedded in the input grammar, which is used to specify semantic actions; or, for simple applications, to specify a direct implementation of syntax directed translation within the grammar.

	gocc has been successfully used to develop a query language compiler; a configuration/control language for a distributed system; as well as a parser for protocol messages specified in ABNF~\cite{ABNF}. It is currently used in the development of an ASN.1 compiler.

	gocc was designed to be easy to use and experience has shown that its users require very little background knowledge of language and compiler theory to apply it to simple language applications, such as syntax directed translation. An appreciation of mathematical formalism is usually enough and this guide is intended to provide sufficient information for such users, provided they understand:
	\begin{itemize}
		\item How to use context free grammars;
		\item How to separate lexical, syntactic and semantic analysis.
	\end{itemize}

	More complex applications, such as compiled languages and advanced protocol message parsing require more background, especially:
	\begin{itemize}
		\item The relationship between languages, grammars and automata;
		\item The relationship between regular and context free grammars;
		\item The equivalence of finite state automata with regular grammars; and of pushdown automata with context free grammars;
		\item The meaning and limits of top down/predictive parsing, bottom up parsing and deterministic parsing;
		\item The implications of language ambiguity and shift/reduce conflicts;
		\item The implications of grammars that generate languages outside the class of context free languages;
		\item Compiler design.
	\end{itemize}

	The author  considers the {\em Dragon Book}~\cite{Dragon Book} still the best reference for these topics. The reader is also directed to \cite{Modern Compiler Design} for a modern treatment of compiler design, as well as \cite{Parsing} for a comprehensive treatment of the parsing techniques used in gocc.

	gocc was conceived out of need in the year after Google released the \Go language. At the time there was no other parser generator available, which could generate parsers in the \Go language. The author set out to create a parser generator for the set of all deterministically parseable languages, which implied the LR(1) technique. Although there are now alternatives to gocc available to \Go programmers we offer gocc to the community in the hope that someone may find it useful and as a token of thanks to Google for the gift of \Go.

\section{Copyright}
	\begin{verbatim}
		Copyright 2012 Vastech SA (PTY) LTD
		
		    Licensed under the Apache License, Version 2.0 (the "License");
		    you may not use this file except in compliance with the License.
		    You may obtain a copy of the License at
		    
		        http://www.apache.org/licenses/LICENSE-2.0
		    
		    Unless required by applicable law or agreed to in writing, software
		    distributed under the License is distributed on an "AS IS" BASIS,
		    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		    See the License for the specific language governing permissions and
		    limitations under the License.
	\end{verbatim}



\section{Definition of terms}
	\begin{longtable}{ll}
		\bf AST & Abstract syntax tree\\
		\bf SDT	& Syntax Directed Translation Scheme \\
	\end{longtable}

\section{Getting started}
	\begin{enumerate}
		\item Download and install \Go from \url{http://golang.org}.

		\item Set your \Code{GOPATH} environment variable. See \url{http://golang.org/doc/code.html}.

		\item Install \gocc:
			\begin{enumerate}
				\item In your command line run: \Code{go get code.google.com/p/gocc/} (go get will git clone gocc into GOPATH/src/code.google.com/p/gocc and run go install)

					or 

				\item Alternatively clone the repository: \url{https://code.google.com/p/gocc/source/checkout}. Followed by:
				\verb|go install code.google.com/p/gocc|.
			\end{enumerate}

	\end{enumerate}

	Test your installation by running \verb|make test| from \verb|$GOPATH/src/code.google.com/p/gocc|.

\section{How to create and use a parser with gocc}
	Figure~\ref{fig:hl design} shows the high-level design of a user application, which uses a parser generated with gocc.
	\begin{itemize}
		\item The user creates a target grammar conforming to the gocc BNF standard (see appendix~\ref{sec:gocc bnf}).

		\item gocc reads the target grammar and generates the components shown in heavy outline in fig~\ref{fig:hl design}, i.e.: the scanner, parser, token and error packages. 

		{\em Note:} the scanner is an optionally generated component (see section~\ref{sec:commandline}).

		\item The user creates a user application, which creates the scanner and parser objects. 

		\item The user also creates a package called by the compiler to execute semantic actions for each recognised production of the target grammar. The methods of the semantic package provided by the user correspond to the method calls specified in the SDT statements in the target grammar.

		\item The user application initialises a scanner object with the input text. Then it calls the \Code{Parse(...)} method of the parser.

		\item Once created, the scanner and parser objects may be used repeatedly for successive inputs. For each input the scanner must be initialised with the next input text and the parser's \Code{Parse(...)} method called with a reference to the scanner.	

		\item The parser reads a stream of tokens (lexical elements) from the scanner (lexer) by repeatedly calling the scanner interface method, \Code{scanner.Scan()}. 

		\begin{verbatim}
			type Scanner interface {
			    Scan() (*token.Token, token.Position)
			}
		\end{verbatim}

		Each call to \Code{scanner.Scan} returns two values: a pointer to token.Token and token.Position. The former contains information of the last token scanned and the latter its position in the input text.

		\item The scanner reads a stream of input characters and recognizes the tokens specified in the target grammar. After reaching the end of input it returns the end of input token to every call to \Code{scanner.Scan()}.

		\item Whenever the parser recognises the complete body of a production of the target grammar, it calls the function specified in the SDT element associated with that production. The parsed symbols of the recognised production are passed as parameters to the SDT function (see section~\ref{sec:target grammar}). The result of the SDT call is placed on the parser's stack as an attribute of the recognised language symbol.

		\item When the parser recognises the complete start production of the grammer it calls its associated SDT element. The result of the SDT call is returned to the user application as type \Code{interface\{\}} together with a \Code{nil} error value.

		\item If the parser encounters an error in the input it may perform automatic error recovery (see section~\ref{sec:error recovery}). If the error is recoverable the parser places all the parsed language symbols associated with the error (completed productions as well as tokens) in a symbol of type \Code{*error.Error} and places this symbol on the parser stack. The parser then discards input tokens until it encounters an input token which may validly follow the recovered production and parsing continues normally. When error recovery is specified the user application must handle the error symbols which it may receive as attributes in calls to SDT elements, or which may be returned as a top-level result of the parse to the calling application.

		\item If the parser encounters an irrecoverable error it returns a \Code{nil} error value together with an {\em indeterminate} parse result.
	\end{itemize}

	\begin{figure}
		\includegraphics[scale=1]{"hl_design"}
		\caption{High-level design}
		\label{fig:hl design}
	\end{figure}

\section{First example}
	The source code of the following example can be found at 

	\verb|$GOPATH/src/code.google.com/p/gocc/example/calc| 

	The grammar implements the simple desktop calculator described in~\cite{Dragon Book}. The generated code is both a parser and an interpreter for the calculator.

	The following files are provided by the user:
	\begin{verbatim}
		> ls -R calc/
		calc.bnf	calc_test.go	
	\end{verbatim}

	\begin{description}
		\item[calc.bnf] contains the grammar for this example.

		\item[calc\_test.go] will be used to execute the generated code. It represents the user application.

	\end{description}

	\subsection{Step 1: generate code}
		To generate code we run gocc from the directory containing \verb|calc.bnf| with the following command:

		\begin{verbatim}
			> gocc -s calc.bnf
		\end{verbatim}

		gocc is invoked with the option, \verb|-s|, to generate a default scanner for the project. See section~\ref{sec:scanner} for more about the scanner.

		After running gocc we see that the directory structure now contains the following files:

		\begin{verbatim}
			> ls -R calc/
			calc.bnf		errors			scanner			sm_first_bodies.txt	sm_transitions.dot
			calc_test.go		parser			sm_first.txt		sm_sets.txt		token

			calc/errors:
			errors.go

			calc/parser:
			parser.go	tables.go

			calc/scanner:
			scanner.go

			calc/token:
			token.go	tokens.go
		\end{verbatim}

		The generated files are:
		\begin{description}
			\item[sm\_*.txt] Files containing information about the table generation process. They are useful for debugging.

			\item[errors/errors.go] Declares \verb|type Error|, which is used during automatic recovery from errors in the input. See section~\ref{sec:error recovery} for more details.

			\item[parser/parser.go, parser/tables.go] contain the parser for the target language with the interpreter code embedded.

			\item[token/token.go, token/tokens.go] contain the declaration of the tokens of the grammar.
		\end{description}

	\subsection{The example grammar}
		\begin{verbatim}
			<< import "calc/token" >>

			Calc : Expr              
			;

			Expr :
			      Expr "+" Term      << $0.(int64) + $2.(int64), nil >>
			    | Term			
			;

			Term :
			      Term "*" Factor    << $0.(int64) * $2.(int64), nil >>
			    | Factor			
			;

			Factor :
			      "(" Expr ")"       << $1, nil >>
			    | int_lit            << $0.(*token.Token).IntValue() >>
			;
		\end{verbatim}

		The BNF of the example starts with an optional initial SDT. It declares the imported package \verb|calc/token|, which will be used in SDT statements of some productions of the grammar. 

		The text of the initial SDT is expanded at the start of the \verb|parser/tables.go|.

		Every production alternative of the grammar has either an implicit or explicit SDT, which translates to a function with the signature:

		\begin{verbatim}
			func ([]parser.Attrib)(parser.Attrib, error)
		\end{verbatim}

		where \verb|parser.Attrib| is of type \verb|interface{}|.

		When the whole body of a production alternative has been recognised, the parser calls the associated SDT function with the attributes of the recognised language symbols of that body. If the SDT function returns a non-nil error the parser stops and returns the error to the calling user application. If the SDT function returns a nil error the parser replaces the recognised language symbols of the production on its stack with the attribute returned by the SDT function.

		Any expression in a production's SDT must return \verb|(parser.Attrib, nil)|. The expression may refer to the attributes of the language symbols of the recognised production body, $P : x_0 .. x_n$ as $\$0 .. \$n$.

		An implicit SDT function is of the form:

		\begin{verbatim}
			func(X []parser.Attrib) (parser.Attrib, error) {
			    return X[0], nil
			}
		\end{verbatim}

		Therefore the implicit (omitted) SDT is equivalent to the explicit SDT, \verb|<< $0, nil >>|.


		The first production of the grammar, \verb|Calc|,  is the start production. The body of \verb|Calc| contains only one non-terminal: \verb|Expr|, which is used recursively in the grammar. It has an implicit SDT which returns the attribute of \verb|Expr|.

		The first alternative of \verb|Expr| returns the sum of the attributes of \verb|Expr| and \verb|Term| after casting them to \verb|int64|. The second alternative returns the attribute of \verb|Term|.

		The first alternative of \verb|Term| returns the product of \verb|Term| and \verb|Factor| after casting them to \verb|int64|. The second term returns the attribute of \verb|Factor|.

		The first alternative of \verb|Factor| simply returns the attribute of the parenthesised \verb|Expr|. The second alternative returns the value of a numeric token.

		In the second alternative of \verb|Factor| we use a method on the input token, which returns 
		\verb|(int64, error)|. Therefore the types of all numbers are \verb|int64|.

	\subsection{The test program}
		The root folder of the \Code{Calc} example contains \Code{calc\_test.go}, which has the following test program. In addition to testing the code it shows how to initialise and use the generated scanner and parser/interpreter.

		\begin{verbatim}
			package main

			import(
			    "code.google.com/p/gocc/example/calc/parser"
			    "code.google.com/p/gocc/example/calc/scanner"
			    "code.google.com/p/gocc/example/calc/token"
			    "fmt"
			    "testing"
			)

			type TI struct{
			    src string
			    expect int64
			}

			var testData = []*TI{
			    &TI{"1 + 1", 2},
			    &TI{"1 * 1", 1},
			    &TI{"1 + 2 * 3", 7},
			}

			func Test1(t *testing.T) {
			    s := &scanner.Scanner{}
			    p := parser.NewParser(parser.ActionTable, parser.GotoTable, 
			                          parser.ProductionsTable, token.CALCTokens)
			    pass := true
			    for _, ts := range testData {
			        s.Init([]byte(ts.src), token.CALCTokens)
			        sum, err := p.Parse(s)
			        if err != nil {
			            pass = false
			            t.Log(err.Error())
			        }
			        if sum != ts.expect {
			            pass = false
			            t.Log(fmt.Sprintf("Error: %s = %d. Got %d\n", ts.src, sum, ts.expect ))
			        }
			    }
			    if !pass {
			    t.Fail()
			    }
			}

		\end{verbatim}

	\subsection{Step 2: running \Code{go test}}
		From the root folder of the \Code{Calc} example, execute the following command:

		\begin{verbatim}
			> go test -v .
		\end{verbatim}

		which generates the following output:

		\begin{verbatim}
			warning: building out-of-date packages:
			    code.google.com/p/gocc/example/calc/token
			    code.google.com/p/gocc/example/calc/errors
			    code.google.com/p/gocc/example/calc/parser
			    code.google.com/p/gocc/example/calc/scanner
			installing these packages with 'go test -i' will speed future tests.

			=== RUN Test1
			--- PASS: Test1 (0.00 seconds)
			PASS
			ok  	code.google.com/p/gocc/example/calc	0.106s		\end{verbatim}

		{\em Congratulations!} You have executed your first gocc-generated code.

\section{Commandline syntax}\label{sec:commandline}
	\begin{verbatim}
		gocc is an LR(1) parser generator.

		Usage:
		    gocc [options] bnf_file

		gocc reads the BNF target grammar from bnf_file and generates a parser 
		(and optionally a scanner) for the grammar.

		Options:
		    -a          Automatically resolve LR(1) conflicts.
		                default: off

		    -o          Output directory.
		                default: working directory (current directory)
		                Run gocc without arguments to see default.

		    -p          package of the parser application.
		                default: working directory without prefix: $GOPATH/src/
		                Run gocc without arguments to see default.

		    -s          Generate a scanner
		                default: false

		    -u          allow unreachable productions 
		                (only recommended during debugging of grammar)

		    -v          verbose
		                Shows list of LR(1) conflicts.
	\end{verbatim}

\section{What about a scanner?}\label{sec:scanner}
	Currently gocc (optionally) generates a very simple scanner, intended to be extended as required by the user.

	A lexer generator, based on the target grammar, is planned for the near future.

\section{Handling LR(1) conflicts} \label{sec:lr conflicts}
	If a target grammer is outside the class of LR(1) grammars it cannot be parsed deterministically with one symbol lookahead. This condition manifests as LR(1) conflicts, of which there are two types:

	\begin{description}
		\item[Shift/Reduce conflict:] The parser has recognised a valid production body on the stack, and can reduce it to the corresponding production. 

		However, the same symbols are also a valid prefix of the body of another, longer production. The parser could continue to shift the input symbols and attempt to recognise the longer production.

		\gocc uses the {\em maximal-munch rule} (see~\cite{Modern Compiler Design}) to resolve this conflict by always choosing shift over reduce. The longest valid production will therefore always be recognised.

		\item[Reduce/Reduce conflict:] The parser has recognised a valid sequence of symbols, which can be reduced to more than one production.

		\gocc will always reduce the production that was declared first in the grammar.
	\end{description}

\section{Example: reduce/reduce conflict handling} \label{sec:example rr}
	The source code of the following example can be found at

	\verb|$GOPATH/src/code.google.com/p/gocc/example/reducereduce|

	\begin{verbatim}
	RR : A | B ;

	B : a ;

	A : a | A a ;

	\end{verbatim}

	When we run \gocc on \verb|$GOPATH/src/code.google.com/p/gocc/example/reducereduce/rr.bnf| we discover a reduce/reduce conflict:

	\begin{verbatim}
		> gocc -v rr.bnf
		LR(1) conflict: S4 Reduce:3(B) / Reduce:4(A)
		ABORTING: 1 LR(1) conflicts
	\end{verbatim}

	\gocc does not generate code because the default for automatic LR(1) conflict resolution is \verb|off|. From the output we see that \gocc could reduce either of production \verb|B| or \verb|A| in state \verb|4|.

	\gocc generates a number of informational files, and at this point we turn to 

	\verb|$GOPATH/src/code.google.com/p/gocc/example/reducereduce/sm_sets.txt|

	to analyse the conflict.

	\verb|sm_set.txt| contains the LR(1) sets, which will be translated into the states of the parser. Each state contains a set of {\em LR(1)  items}, which specifies what the parser expects in that state. 

	An LR(1) item is a production alternative with the position of the parser marked by a $\bullet$, and the next symbol expected after this production body, in double angle brackets. Alternatives of a production are in  separate items. For example: 

	$A : a\bullet <<\$>>$

	indicates that the compiler has recognised the production alternative, \verb|A : a| and  next expects to see the end of input character, \verb|$|.

	Getting back to our R/R conflict, \verb|S4|  in \verb|sm_states.txt| represents state 4 and contains the following items:

	\[
		\begin{array}{ll}
			S4 \{ \\
			    & A : a\bullet  <<\$>> \\
			    & B : a\bullet  <<\$>> \\
			    & A : a\bullet  <<a>> \\
			\} \\
		\end{array}
	\]

	We see that the bodies of all items in S4 are the same and that the parser has completely recognised them. Two items reduce to production \verb|A| and one to production \verb|B|. This is the reduce/reduce conflict: \verb|A| vs \verb|B|.

	When \gocc is run with the \verb|-a| option it will automatically resolve this conflict by reducing production \verb|B|, because it is declared in \verb|rr.bnf| before \verb|A|:

	\begin{verbatim}
		> gocc -a rr.bnf
		Resolved 0 shift/reduce, 1 reduce/reduce conflicts
	\end{verbatim}

\section{Example: Shift/reduce conflict handling} \label{sec:example sr}
	The source code of the following example can be found at

	\verb|$GOPATH/src/code.google.com/p/gocc/example/shiftreduce|

	It is the classic example of the dangling else in the \Clang:

	\begin{verbatim}
		Stmt :
		        if expr then Stmt
		    |   if expr then Stmt else Stmt
		;
	\end{verbatim}

	When we run \gocc on \verb|$GOPATH/src/code.google.com/p/gocc/example/shiftreduce/sr.bnf| we discover a shift/reduce conflict:

	\begin{verbatim}
		> gocc -v sr.bnf
		LR(1) conflict: S11 Shift:12 / Reduce:1(Stmt)
		ABORTING: 1 LR(1) conflicts
	\end{verbatim}

	The problem is in the last two items of state 11, where the next symbol is \verb|else| and the parser can both shift and reduce:

	\[
		\begin{array}{ll}
			S11 \{ \\
			  & Stmt : if\ expr\ then\ Stmt\bullet\ <<\$>> \\
			  & Stmt : if\ expr\ then\ Stmt\ \bullet else\ Stmt\ <<\$>> \\
			  & Stmt : if\ expr\ then\ Stmt \bullet\ <<else>> \\
			  & Stmt : if\ expr\ then\ Stmt\ \bullet else\ Stmt\ <<else>> \\
			\} \\
		\end{array}
	\]

	When automatic LR(1) conflict resolution is selected by the \verb|-a| option, \gocc resolves this conflict in the same way as specified in the \Clang\ specification: by shifting and parsing the longest valid production ({\em maximal-munch}). This means recognising the \verb|else|-statement as part of the second \verb|if|.

\section{Example: Using an AST} \label{sec:example ast}
	The following example illustrates the use of user-provided SDT rules to produce a simple abstract syntax tree (AST) for a list of simple statements. 

	The code for the example can be found at

	\verb|$GOPATH/src/code.google.com/p/gocc/example/astx|

	The grammar is in \verb|ast.bnf|:

	\begin{verbatim}
		<< import "code.google.com/p/gocc/example/astx/ast" >>

		StmtList : 
		      Stmt             << ast.NewStmtList($0) >>
		    | StmtList Stmt    << ast.AppendStmt($0, $1) >>
		;

		Stmt : 
		      id               << ast.NewStmt($0) >>
		;
	\end{verbatim}

	At the top of the grammar is an SDT containing an import statement for the user-provided package, 
	\verb|code.google.com/p/gocc/example/astx/ast|.

	The production SDTs will use functions from the package, \verb|ast|.

	The start production, \verb"StmtList" returns a tuple: \verb|(ast.StmtList, error)|, as we can see from the code of functions 
	\verb|NewStmtList| and \verb|AppendStmt| in 

	\verb|$GOPATH/src/code.google.com/p/gocc/example/astx/ast.go|:

	\begin{verbatim}
		package ast

		import(
		    "code.google.com/p/gocc/example/astx/token"
		)

		type (
		    StmtList	[]Stmt
		    Stmt 	string
		)

		func NewStmtList(stmt interface{}) (StmtList, error) {
		    return StmtList{stmt.(Stmt)}, nil
		}

		func AppendStmt(stmtList, stmt interface{}) (StmtList, error) {
		    return append(stmtList.(StmtList), stmt.(Stmt)), nil
		}	

		func NewStmt(stmtList interface{}) (Stmt, error) {
		    return Stmt(stmtList.(*token.Token).Lit), nil
		}
	\end{verbatim}

	Note the following:

	\begin{itemize}
		\item The attributes of the language symbols in the production are passed to the SDT function calls as parameters, referred to as $\$0, \$1, ...$

		\item The type of the parameters passed to the functions in the SDTs is \verb|interface{}| and must be type asserted by the called function to the expected type.

		\item The parser will return the result of a successful parse, a \verb"StmtList", to the calling application as type \verb"interface{}". The calling application must type assert the returned value to the expected type.
	\end{itemize}

	If we run 

	\verb"go test -v ." 

	from the directory 

	\verb|$GOPATH/src/code.google.com/p/gocc/example/astx/| 

	we get the following ouput:

	\begin{verbatim}
		> go test -v .
		warning: building out-of-date packages:
		        code.google.com/p/gocc/example/astx/token
		        code.google.com/p/gocc/example/astx/ast
		        code.google.com/p/gocc/example/astx/errors
		        code.google.com/p/gocc/example/astx/parser
		        code.google.com/p/gocc/example/astx/scanner
		installing these packages with 'go test -i .' will speed future tests.

		=== RUN TestPass
		input: a b c d e f
		output: [a b c d e f]
		--- PASS: TestPass (0.00 seconds)
		=== RUN TestFail
		input: a b ; d e f
		--- FAIL: TestFail (0.00 seconds)
		ast_test.go:23: 	Error: illegal -1(-1) ; @ 1:5, expected one of: id $
		        FAIL
		exit status 1
		FAIL	code.google.com/p/gocc/example/astx	0.015s	\end{verbatim}

	The first test, \verb"TestPass", has a valid input string, \verb|"a b c d e f"|; and parses successfully; and returns the expected StmtList, \verb|[a b c d e f]|.

	The input to the second test, \verb|TestFail|, contains an invalid identifier, \verb|;|. The parser returns an error, indicating that it encountered an invalid token when it expect a token of type \verb|id| or the end of input.

\section{Example: Parser error recovery} \label{sec:error recovery}
	Without error recovery a \gocc parser terminates when it reaches the first error in the input. Sometimes it is convenient to attempt to continue the parse and this can be achieved in \gocc by specifying in the grammar which productions can recover from errors in the input. 

	When the \gocc reserved word, \verb|error|, is the first symbol in a production alternative, it indicates that that production can recover from input errors.

	We modify the AST example to illustrate error recovery. See:

	\verb|$GOPATH/src/code.google.com/p/gocc/examples/errorrecovery/er.bnf|:

	\begin{verbatim}
		<< import "code.google.com/p/gocc/example/errorrecovery/ast" >>

		StmtList : 
		      Stmt             << ast.NewStmtList($0) >>
		    | StmtList Stmt    << ast.AppendStmt($0, $1) >>
		;

		Stmt : 
		      id               << ast.NewStmt($0) >>
		    | error
		;
	\end{verbatim}

	The production, \verb|Stmt|, now has an alternative: \verb"| error"

	This indicates to \gocc that input errors can be handles in production \verb|Stmt|.

	From the directory, 

	\verb|$GOPATH/src/code.google.com/p/gocc/examples/errorrecovery/|, 

	run \verb|go test| as follows:

	\begin{verbatim}
		> go test -v .
		warning: building out-of-date packages:
		        code.google.com/p/gocc/example/errorrecovery/token
		        code.google.com/p/gocc/example/errorrecovery/ast
		        code.google.com/p/gocc/example/errorrecovery/errors
		        code.google.com/p/gocc/example/errorrecovery/parser
		        code.google.com/p/gocc/example/errorrecovery/scanner
		installing these packages with 'go test -i .' will speed future tests.

		=== RUN TestFail
		input: a b ; d e f
		parser.firstRecoveryState: State 3
		parser.firstRecoveryState: State 1, canRecover, true
		output: [
		    a
		    error:
		        Err: nil
		        ErrorToken: ";"(-1)
		        ErrorPos: 1:5
		        ErrorSymbols: ["b"(1)]
		        ExpectedTokens: [error $ id]
		    d
		    e
		    f
		]
		--- PASS: TestFail (0.00 seconds)
		PASS		ok      code.google.com/p/gocc/example/errorrecovery	0.015s
	\end{verbatim}

	The test case can be found in \\
	\verb|$GOPATH/src/code.google.com/p/gocc/examples/errorrecovery/er_test.go|. \\
	It calls the parser with input string, \verb|"a b ; d e f"|, which contains an invalid token, \verb|;|.

	From the \verb|go test| output we see that the parser successfully recovered from the input error and returned a \verb|StmtList| containing an error symbol between \verb|[a| and \verb|d, e, f]|. The \verb|id|, \verb|b|, was lost in the error recovery. \TBDx{Explain exactly why the 'b' was lost.} The errored token was \verb|;| (invalid token) when the parser expected one of \verb|error, $| (end of input) or \verb|id|.

	The parser returned an error value of \verb|nil|, because it successfully recovered from the error.

	{\bf Note:} \\
	\begin{enumerate}
		\item When error recovery is allowed the user's code must expect errors and handle the appropriately in the code called by the production SDTS, as well as by the code handling the results returned by the parser.

		\item The parser will still return a non-\verb|nil| error value if it encounters an irrecoverable error.
	\end{enumerate}

	See \verb|$GOPATH/src/code.google.com/p/gocc/examples/errorrecovery/errors/error.go| for the definition of errors.Error.

\appendix
\section{gocc target grammar}\label{sec:gocc bnf}
	A gocc target grammar is written in UTF-8. See section~\ref{sec:lexical elements} for a definition of the lexical elements of a gocc target grammar. 

	\begin{verbatim}
	Grammar : [sdt_lit] Productions 
	        ;

	Productions : Production					
	            | Production Productions			
	            ;

	Production : id ":" Alternatives		
	           ;

	Alternatives : Body					
	             | Body "|" Alternatives	
	             ; 

	Body : Symbols					
	     | Symbols sdt_lit			
	     | "error"
	     | "error" Symbols
	     | "error" Symbols sdt_lit
	     | "empty"
	     ;

	Symbols	: Symbol					
	        | Symbol Symbols			
	        ;

	Symbol : id							
	       | string						
	       | char	
	       ;
	\end{verbatim}

\section{Lexical elements} \label{sec:lexical elements}
	\TBDx{Expand this appendix.}
	
	The basic unit of lexical elements is the UTF-8 character.

	gocc has the following tokens:

	\begin{description}
		\item[id] An id starts with a Unicode letter and is followed by any sequence of unicode letter or '\_'

		\item[string] Strings can be both types of \Go string literal: interpreted strings (e.g.: \verb|"Hello World"|) or raw strings (\verb|`Hello World`|).

		\item[char] Can be any of:

			\begin{itemize}
				\item A simple character declaration, e.g.: 'a';
				\item An octal character literal, e.g.: '\textbackslash 141';
				\item A hexadecimal character literal, e.g.: '\textbackslash x61';
				\item A unicode literal, e.g.: '\textbackslash u61' or '\textbackslash U0061';
				\item Or an escaped character, such as '\textbackslash n'.
			\end{itemize}

			See the \Go specification~\cite{gospec} for details.

		\item[sdt\_lit] An SDT literal is enclosed in double angle brackets, e.g.: 
			\begin{verbatim}
				<< ast.AddFoo($0, $1) >>
			\end{verbatim}
	\end{description}

	\gocc supports both types of \Go comments:
	\begin{enumerate}
		\item Line comments start with the sequence \verb|//| and stop at the end of the line.
		\item General comments start with the sequence \verb|/*| and continue through the sequence \verb|*/|.
	\end{enumerate}
		

\nocite{Parsing, Modern Compiler Design, Dragon Book, ABNF}
\begin{thebibliography}{99}
	\bibitem{Parsing}
	Dick Grune and Ceriel J.H. Jacobs.
	\newblock {\em Parsing Techniques. A Practical Guide. Second Edition}.
	\newblock Monographs in Computer Science, Springer, 2008
	
	\bibitem{Modern Compiler Design}
	Dick Grune, Kees van Reeuwijk, Henri E. Bal, Ceriel J.H. Jacobs and Koen Langendoen.
	\newblock {\em Modern Modern Compiler Design. Second Edition}.
	\newblock Springer 2012

	\bibitem{Dragon Book}
	Alfred V. Aho, Monica S. Lam, Ravi Sethi and Jeffrey D. Ullman.
	\newblock {\em Compilers. Principles, Techniques, \& Tools. Second Edition}.
	\newblock Addison Wesley, 2007

	\bibitem{ABNF}
	D. Crocker, Ed.
	\newblock{\em Augmented BNF for Syntax Specifications: ABNF}
	\newblock RFC 5234, January 2008

	\bibitem{gospec}
	{\em The Go Language Specification}
	\newblock \url{http://golang.org/ref/spec}

	
\end{thebibliography}


\end{document}
